#!/command/with-contenv bash
# SPDX-FileCopyrightText: Â© 2025 Nfrastack <code@nfrastack.com>
#
# SPDX-License-Identifier: BSD-3-Clause

herald_bootstrap_filesystem() {
    create_folder "${CONFIG_PATH}" "${HERALD_USER}":"${HERALD_GROUP}" 750
    case "${LOG_TYPE,,}" in
        "file" | "both" )
            create_folder "${CONFIG_PATH}" "${HERALD_USER}":"${HERALD_GROUP}" 750
            create_logrotate herald "${LOG_PATH%/}"/"${LOG_FILE}" herald "${HERALD_USER}" "${HERALD_GROUP}"
        ;;
    esac
}

herald_generate_config() {
    local config_file="${CONFIG_PATH%/}/${CONFIG_FILE}"

    if [ ! -f "${config_file}" ]; then
        s6-setuidgid "${HERALD_USER}" touch "${config_file}"
    fi

    if [ "${HERALD_SETUP_TYPE,,}" = "auto" ]; then
        local modify_config="s6-setuidgid ${HERALD_USER} yq -i "
        print_info "Generating configuration file ${CONFIG_PATH%/}/${CONFIG_FILE} for herald"

        # Generate base structure
        ${modify_config} '.general = {}' "${config_file}"
        ${modify_config} '.inputs = {}' "${config_file}"
        ${modify_config} '.outputs = {}' "${config_file}"
        ${modify_config} '.domains = {}' "${config_file}"

        # General settings
        [ -n "${LOG_LEVEL}" ] && ${modify_config} ".general.log_level = \"${LOG_LEVEL}\"" "${config_file}"
        [ -n "${LOG_TIMESTAMPS}" ] && ${modify_config} ".general.log_timestamps = ${LOG_TIMESTAMPS,,}" "${config_file}"
        [ -n "${DRY_RUN}" ] && ${modify_config} ".general.dry_run = ${DRY_RUN,,}" "${config_file}"

        # Docker input configuration
        if [ -n "${DOCKER_API_URL}" ]; then
            ${modify_config} '.inputs.docker = {"type": "docker"}' "${config_file}"
            ${modify_config} ".inputs.docker.api_url = \"${DOCKER_API_URL}\"" "${config_file}"
            [ -n "${DOCKER_API_AUTH_USER}" ] && ${modify_config} ".inputs.docker.api_auth_user = \"${DOCKER_API_AUTH_USER}\"" "${config_file}"
            [ -n "${DOCKER_API_AUTH_PASS}" ] && ${modify_config} ".inputs.docker.api_auth_pass = \"${DOCKER_API_AUTH_PASS}\"" "${config_file}"
            [ -n "${DOCKER_INTERVAL}" ] && ${modify_config} ".inputs.docker.interval = \"${DOCKER_INTERVAL}s\"" "${config_file}"
            [ -n "${DOCKER_PROCESS_EXISTING}" ] && ${modify_config} ".inputs.docker.process_existing = ${DOCKER_PROCESS_EXISTING,,}" "${config_file}"
            [ -n "${DOCKER_EXPOSE_CONTAINERS}" ] && ${modify_config} ".inputs.docker.expose_containers = ${DOCKER_EXPOSE_CONTAINERS,,}" "${config_file}"
            [ -n "${DOCKER_SWARM_MODE}" ] && ${modify_config} ".inputs.docker.swarm_mode = ${DOCKER_SWARM_MODE,,}" "${config_file}"
            [ -n "${DOCKER_RECORD_REMOVE_ON_STOP}" ] && ${modify_config} ".inputs.docker.record_remove_on_stop = ${DOCKER_RECORD_REMOVE_ON_STOP,,}" "${config_file}"
            [ -n "${DOCKER_LOG_LEVEL}" ] && ${modify_config} ".inputs.docker.log_level = \"${DOCKER_LOG_LEVEL}\"" "${config_file}"

            # Docker TLS configuration
            if [ -n "${DOCKER_TLS_VERIFY}" ] || [ -n "${DOCKER_TLS_CA_FILE}" ] || [ -n "${DOCKER_TLS_CERT_FILE}" ] || [ -n "${DOCKER_TLS_KEY_FILE}" ]; then
                ${modify_config} '.inputs.docker.tls = {}' "${config_file}"
                [ -n "${DOCKER_TLS_VERIFY}" ] && ${modify_config} ".inputs.docker.tls.verify = ${DOCKER_TLS_VERIFY,,}" "${config_file}"
                [ -n "${DOCKER_TLS_CA_FILE}" ] && ${modify_config} ".inputs.docker.tls.ca = \"${DOCKER_TLS_CA_FILE}\"" "${config_file}"
                [ -n "${DOCKER_TLS_CERT_FILE}" ] && ${modify_config} ".inputs.docker.tls.cert = \"${DOCKER_TLS_CERT_FILE}\"" "${config_file}"
                [ -n "${DOCKER_TLS_KEY_FILE}" ] && ${modify_config} ".inputs.docker.tls.key = \"${DOCKER_TLS_KEY_FILE}\"" "${config_file}"
            fi
        fi

        # Traefik input configuration
        if [ -n "${TRAEFIK_API_URL}" ]; then
            ${modify_config} '.inputs.traefik = {"type": "traefik"}' "${config_file}"
            ${modify_config} ".inputs.traefik.api_url = \"${TRAEFIK_API_URL}\"" "${config_file}"
            [ -n "${TRAEFIK_API_AUTH_USER}" ] && ${modify_config} ".inputs.traefik.api_auth_user = \"${TRAEFIK_API_AUTH_USER}\"" "${config_file}"
            [ -n "${TRAEFIK_API_AUTH_PASS}" ] && ${modify_config} ".inputs.traefik.api_auth_pass = \"${TRAEFIK_API_AUTH_PASS}\"" "${config_file}"
            [ -n "${TRAEFIK_INTERVAL}" ] && ${modify_config} ".inputs.traefik.interval = \"${TRAEFIK_INTERVAL}s\"" "${config_file}"
            [ -n "${TRAEFIK_PROCESS_EXISTING}" ] && ${modify_config} ".inputs.traefik.process_existing = ${TRAEFIK_PROCESS_EXISTING,,}" "${config_file}"
            [ -n "${TRAEFIK_RECORD_REMOVE_ON_STOP}" ] && ${modify_config} ".inputs.traefik.record_remove_on_stop = ${TRAEFIK_RECORD_REMOVE_ON_STOP,,}" "${config_file}"
            [ -n "${TRAEFIK_LOG_LEVEL}" ] && ${modify_config} ".inputs.traefik.log_level = \"${TRAEFIK_LOG_LEVEL}\"" "${config_file}"

            # Traefik TLS configuration
            if [ -n "${TRAEFIK_TLS_VERIFY}" ] || [ -n "${TRAEFIK_TLS_CA_FILE}" ] || [ -n "${TRAEFIK_TLS_CERT_FILE}" ] || [ -n "${TRAEFIK_TLS_KEY_FILE}" ]; then
                ${modify_config} '.inputs.traefik.tls = {}' "${config_file}"
                [ -n "${TRAEFIK_TLS_VERIFY}" ] && ${modify_config} ".inputs.traefik.tls.verify = ${TRAEFIK_TLS_VERIFY,,}" "${config_file}"
                [ -n "${TRAEFIK_TLS_CA_FILE}" ] && ${modify_config} ".inputs.traefik.tls.ca = \"${TRAEFIK_TLS_CA_FILE}\"" "${config_file}"
                [ -n "${TRAEFIK_TLS_CERT_FILE}" ] && ${modify_config} ".inputs.traefik.tls.cert = \"${TRAEFIK_TLS_CERT_FILE}\"" "${config_file}"
                [ -n "${TRAEFIK_TLS_KEY_FILE}" ] && ${modify_config} ".inputs.traefik.tls.key = \"${TRAEFIK_TLS_KEY_FILE}\"" "${config_file}"
            fi
        fi

        # Caddy input configuration
        if [ -n "${CADDY_API_URL}" ]; then
            ${modify_config} '.inputs.caddy = {"type": "caddy"}' "${config_file}"
            ${modify_config} ".inputs.caddy.api_url = \"${CADDY_API_URL}\"" "${config_file}"
            [ -n "${CADDY_API_AUTH_USER}" ] && ${modify_config} ".inputs.caddy.api_auth_user = \"${CADDY_API_AUTH_USER}\"" "${config_file}"
            [ -n "${CADDY_API_AUTH_PASS}" ] && ${modify_config} ".inputs.caddy.api_auth_pass = \"${CADDY_API_AUTH_PASS}\"" "${config_file}"
            [ -n "${CADDY_INTERVAL}" ] && ${modify_config} ".inputs.caddy.interval = \"${CADDY_INTERVAL}s\"" "${config_file}"
            [ -n "${CADDY_PROCESS_EXISTING}" ] && ${modify_config} ".inputs.caddy.process_existing = ${CADDY_PROCESS_EXISTING,,}" "${config_file}"
            [ -n "${CADDY_RECORD_REMOVE_ON_STOP}" ] && ${modify_config} ".inputs.caddy.record_remove_on_stop = ${CADDY_RECORD_REMOVE_ON_STOP,,}" "${config_file}"
            [ -n "${CADDY_LOG_LEVEL}" ] && ${modify_config} ".inputs.caddy.log_level = \"${CADDY_LOG_LEVEL}\"" "${config_file}"

            # Caddy TLS configuration
            if [ -n "${CADDY_TLS_VERIFY}" ] || [ -n "${CADDY_TLS_CA_FILE}" ] || [ -n "${CADDY_TLS_CERT_FILE}" ] || [ -n "${CADDY_TLS_KEY_FILE}" ]; then
                ${modify_config} '.inputs.caddy.tls = {}' "${config_file}"
                [ -n "${CADDY_TLS_VERIFY}" ] && ${modify_config} ".inputs.caddy.tls.verify = ${CADDY_TLS_VERIFY,,}" "${config_file}"
                [ -n "${CADDY_TLS_CA_FILE}" ] && ${modify_config} ".inputs.caddy.tls.ca = \"${CADDY_TLS_CA_FILE}\"" "${config_file}"
                [ -n "${CADDY_TLS_CERT_FILE}" ] && ${modify_config} ".inputs.caddy.tls.cert = \"${CADDY_TLS_CERT_FILE}\"" "${config_file}"
                [ -n "${CADDY_TLS_KEY_FILE}" ] && ${modify_config} ".inputs.caddy.tls.key = \"${CADDY_TLS_KEY_FILE}\"" "${config_file}"
            fi
        fi

        # Cloudflare DNS output configuration
        if [ -n "${CLOUDFLARE_API_TOKEN}" ] || [ -n "${CLOUDFLARE_EMAIL}" ]; then
            ${modify_config} '.outputs.cloudflare = {"type": "dns", "provider": "cloudflare"}' "${config_file}"
            [ -n "${CLOUDFLARE_API_TOKEN}" ] && ${modify_config} ".outputs.cloudflare.api_token = \"${CLOUDFLARE_API_TOKEN}\"" "${config_file}"
            [ -n "${CLOUDFLARE_EMAIL}" ] && ${modify_config} ".outputs.cloudflare.api_email = \"${CLOUDFLARE_EMAIL}\"" "${config_file}"
            [ -n "${CLOUDFLARE_API_KEY}" ] && ${modify_config} ".outputs.cloudflare.api_key = \"${CLOUDFLARE_API_KEY}\"" "${config_file}"
        fi

        # Domains configuration - handle multiple domains with DOMAIN_XX_NAME pattern
        if [ -n "${DOMAIN_NAME}" ] && [ -z "${DOMAIN_01_NAME}" ]; then
            export DOMAIN_01_NAME="${DOMAIN_NAME}"
            unset DOMAIN_NAME
        fi

        if [ -z "${DOMAIN_01_NAME}" ]; then
            print_error "Need to set DOMAIN_01_NAME variable to configure domains"
            exit 1
        fi

        # configure domains
        create_domain() {
            padded_i=$(printf "%02d" $i)

            # Get domain variables
            domain_name_var="DOMAIN_${padded_i}_NAME"
            domain_provider_var="DOMAIN_${padded_i}_PROVIDER"
            domain_zone_id_var="DOMAIN_${padded_i}_ZONE_ID"
            domain_record_type_var="DOMAIN_${padded_i}_RECORD_TYPE"
            domain_record_ttl_var="DOMAIN_${padded_i}_RECORD_TTL"
            domain_record_target_var="DOMAIN_${padded_i}_RECORD_TARGET"
            domain_update_existing_var="DOMAIN_${padded_i}_RECORD_UPDATE_EXISTING"
            domain_allow_multiple_var="DOMAIN_${padded_i}_RECORD_ALLOW_MULTIPLE"
            domain_proxied_var="DOMAIN_${padded_i}_RECORD_PROXIED"
            domain_inputs_var="DOMAIN_${padded_i}_INPUTS"
            domain_outputs_var="DOMAIN_${padded_i}_OUTPUTS"

            # Get values
            domain_name="${!domain_name_var}"
            domain_provider="${!domain_provider_var:-cloudflare}"
            domain_zone_id="${!domain_zone_id_var}"
            domain_record_type="${!domain_record_type_var:-CNAME}"
            domain_record_ttl="${!domain_record_ttl_var:-300}"
            domain_record_target="${!domain_record_target_var}"
            domain_update_existing="${!domain_update_existing_var:-false}"
            domain_allow_multiple="${!domain_allow_multiple_var:-false}"
            domain_proxied="${!domain_proxied_var}"
            domain_inputs="${!domain_inputs_var}"
            domain_outputs="${!domain_outputs_var}"

            if [ -n "${domain_name}" ]; then
                domain_key="domain_${padded_i}"
                ${modify_config} ".domains.${domain_key} = {}" "${config_file}"
                ${modify_config} ".domains.${domain_key}.name = \"${domain_name}\"" "${config_file}"

                # Set profiles section
                ${modify_config} ".domains.${domain_key}.profiles = {}" "${config_file}"

                # Configure inputs (default to available input providers)
                if [ -n "${domain_inputs}" ]; then
                    IFS=',' read -ra ADDR <<< "${domain_inputs}"
                    ${modify_config} ".domains.${domain_key}.profiles.inputs = []" "${config_file}"
                    for input in "${ADDR[@]}"; do
                        ${modify_config} ".domains.${domain_key}.profiles.inputs += [\"${input// /}\"]" "${config_file}"
                    done
                else
                    # Default to all configured inputs
                    ${modify_config} ".domains.${domain_key}.profiles.inputs = []" "${config_file}"
                    [ -n "${DOCKER_API_URL}" ] && ${modify_config} ".domains.${domain_key}.profiles.inputs += [\"docker\"]" "${config_file}"
                    [ -n "${TRAEFIK_API_URL}" ] && ${modify_config} ".domains.${domain_key}.profiles.inputs += [\"traefik\"]" "${config_file}"
                    [ -n "${CADDY_API_URL}" ] && ${modify_config} ".domains.${domain_key}.profiles.inputs += [\"caddy\"]" "${config_file}"
                fi

                # Configure outputs
                if [ -n "${domain_outputs}" ]; then
                    # Convert comma-separated list to YAML array
                    IFS=',' read -ra ADDR <<< "${domain_outputs}"
                    ${modify_config} ".domains.${domain_key}.profiles.outputs = []" "${config_file}"
                    for output in "${ADDR[@]}"; do
                        ${modify_config} ".domains.${domain_key}.profiles.outputs += [\"${output// /}\"]" "${config_file}"
                    done
                else
                    # Default to the provider for this domain
                    ${modify_config} ".domains.${domain_key}.profiles.outputs = [\"${domain_provider}\"]" "${config_file}"
                fi

                # Configure record settings
                if [ -n "${domain_record_type}" ] || [ -n "${domain_record_ttl}" ] || [ -n "${domain_record_target}" ] || [ -n "${domain_update_existing}" ] || [ -n "${domain_allow_multiple}" ]; then
                    case "${domain_record_type^^}" in
                        "A" | "AAAA" | "CNAME"  )
                            sanity_var DOMAIN_${padded_i}_RECORD_TARGET "domain record target entered for your record type ${domain_record_type^^} record type"
                        ;;
                    esac
                    if [ "${domain_record_type^^}" = "CNAME" ] && var_true "${domain_allow_multiple}"; then
                        print_error "Can't set DOMAIN_${padded_i}_ALLOW_MULTIPLE=TRUE with DOMAIN_${padded_i}_RECORD_TYPE=TRUE"
                        exit 1
                    fi
                    ${modify_config} ".domains.${domain_key}.record = {}" "${config_file}"
                    [ -n "${domain_record_type}" ] && ${modify_config} ".domains.${domain_key}.record.type = \"${domain_record_type}\"" "${config_file}"
                    [ -n "${domain_record_ttl}" ] && ${modify_config} ".domains.${domain_key}.record.ttl = ${domain_record_ttl}" "${config_file}"
                    [ -n "${domain_record_target}" ] && ${modify_config} ".domains.${domain_key}.record.target = \"${domain_record_target}\"" "${config_file}"
                    [ -n "${domain_update_existing}" ] && ${modify_config} ".domains.${domain_key}.record.update_existing = ${domain_update_existing,,}" "${config_file}"
                    [ -n "${domain_allow_multiple}" ] && ${modify_config} ".domains.${domain_key}.record.allow_multiple = ${domain_allow_multiple,,}" "${config_file}"
                fi

                # Cloudflare-specific settings
                [ -n "${domain_zone_id}" ] && ${modify_config} ".domains.${domain_key}.zone_id = \"${domain_zone_id}\"" "${config_file}"
                [ -n "${domain_proxied}" ] && ${modify_config} ".domains.${domain_key}.proxied = ${domain_proxied,,}" "${config_file}"
            fi
        }
        floop "$(printenv | sort | grep -cE '^DOMAIN_[0-9]+_NAME=')" create_domain EMAN_XX_NIAMOD
    else
        print_info "Skipping configuration generation - using existing configuration file"
    fi
}
