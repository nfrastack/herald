// SPDX-FileCopyrightText: Â© 2025 Nfrastack <code@nfrastack.com>
//
// SPDX-License-Identifier: BSD-3-Clause

package file

import (
	"herald/pkg/output"
	"herald/pkg/output/common"

	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"
)

// ZoneFormat implements OutputFormat for DNS zone files
type ZoneFormat struct {
	*common.CommonFormat
	soa       SOARecord
	nsRecords []string
}

// SOARecord represents an SOA record configuration
type SOARecord struct {
	PrimaryNS  string
	AdminEmail string
	Serial     string
	Refresh    int
	Retry      int
	Expire     int
	Minimum    int
}

// NewZoneFormat creates a new zone format instance
func NewZoneFormat(domain string, config map[string]interface{}) (output.OutputFormat, error) {
	commonFormat, err := common.NewCommonFormat(domain, "zone", config)
	if err != nil {
		return nil, err
	}

	format := &ZoneFormat{
		CommonFormat: commonFormat,
	}

	// Parse SOA configuration
	if err := format.parseSOAConfig(config); err != nil {
		return nil, fmt.Errorf("failed to parse SOA config: %v", err)
	}

	// Parse NS records
	if err := format.parseNSConfig(config); err != nil {
		return nil, fmt.Errorf("failed to parse NS config: %v", err)
	}

	return format, nil
}

// parseSOAConfig parses SOA record configuration
func (z *ZoneFormat) parseSOAConfig(config map[string]interface{}) error {
	soaConfig, ok := config["soa"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("soa configuration is required")
	}

	primaryNS, ok := soaConfig["primary_ns"].(string)
	if !ok {
		return fmt.Errorf("soa.primary_ns is required")
	}

	adminEmail, ok := soaConfig["admin_email"].(string)
	if !ok {
		return fmt.Errorf("soa.admin_email is required")
	}

	z.soa = SOARecord{
		PrimaryNS:  primaryNS,
		AdminEmail: strings.ReplaceAll(adminEmail, "@", "."),
		Serial:     getStringConfigWithDefault(soaConfig, "serial", "auto"),
		Refresh:    getIntConfigWithDefault(soaConfig, "refresh", 3600),
		Retry:      getIntConfigWithDefault(soaConfig, "retry", 900),
		Expire:     getIntConfigWithDefault(soaConfig, "expire", 604800),
		Minimum:    getIntConfigWithDefault(soaConfig, "minimum", 300),
	}

	return nil
}

// parseNSConfig parses NS record configuration
func (z *ZoneFormat) parseNSConfig(config map[string]interface{}) error {
	nsRecordsInterface, ok := config["ns_records"]
	if !ok {
		return fmt.Errorf("ns_records configuration is required")
	}

	nsRecordsSlice, ok := nsRecordsInterface.([]interface{})
	if !ok {
		return fmt.Errorf("ns_records must be a list")
	}

	z.nsRecords = make([]string, 0, len(nsRecordsSlice))
	for _, ns := range nsRecordsSlice {
		nsString, ok := ns.(string)
		if !ok {
			return fmt.Errorf("ns_records entries must be strings")
		}
		z.nsRecords = append(z.nsRecords, nsString)
	}

	return nil
}

// GetName returns the format name
func (z *ZoneFormat) GetName() string {
	return "zone"
}

// Sync writes the zone format to disk
func (z *ZoneFormat) Sync() error {
	return z.SyncWithSerializer(z.serializeZone)
}

// serializeZone handles zone-specific serialization
func (z *ZoneFormat) serializeZone(export *common.ExportData) ([]byte, error) {
	content := z.generateZoneFileContent(export)
	return []byte(content), nil
}

// generateZoneFileContent creates the zone file content
func (z *ZoneFormat) generateZoneFileContent(export *common.ExportData) string {
	var content strings.Builder

	// Get the first domain (zone files are single-domain)
	var domainName string
	var domain *common.BaseDomain
	for name, dom := range export.Domains {
		domainName = name
		domain = dom
		break
	}

	// Header comment
	content.WriteString(fmt.Sprintf("; Zone file for %s\n", domainName))
	content.WriteString(fmt.Sprintf("; Generated by %s at %s\n\n",
		export.Metadata.Generator, export.Metadata.GeneratedAt.Format(time.RFC3339)))

	// Origin
	content.WriteString(fmt.Sprintf("$ORIGIN %s.\n\n", domainName))

	// Generate serial if auto
	serial := z.soa.Serial
	if serial == "auto" {
		serial = generateSerial()
	}

	// SOA Record
	content.WriteString(fmt.Sprintf("%-20s IN    SOA    %s. %s. (\n", domainName+".", z.soa.PrimaryNS, z.soa.AdminEmail))
	content.WriteString(fmt.Sprintf("                              %-12s ; Serial\n", serial))
	content.WriteString(fmt.Sprintf("                              %-12d ; Refresh\n", z.soa.Refresh))
	content.WriteString(fmt.Sprintf("                              %-12d ; Retry\n", z.soa.Retry))
	content.WriteString(fmt.Sprintf("                              %-12d ; Expire\n", z.soa.Expire))
	content.WriteString(fmt.Sprintf("                              %-12d ; Minimum\n", z.soa.Minimum))
	content.WriteString("                              )\n\n")

	// NS Records
	content.WriteString("; NS Records\n")
	for _, ns := range z.nsRecords {
		content.WriteString(fmt.Sprintf("%-20s IN    NS     %s.\n", domainName+".", ns))
	}
	content.WriteString("\n")

	// DNS Records
	content.WriteString("; DNS Records managed by herald\n")

	if domain != nil && len(domain.Records) > 0 {
		// Sort records by name for consistent output
		sort.Slice(domain.Records, func(i, j int) bool {
			if domain.Records[i].Hostname == domain.Records[j].Hostname {
				return domain.Records[i].Type < domain.Records[j].Type
			}
			return domain.Records[i].Hostname < domain.Records[j].Hostname
		})

		// Column headers for clarity
		// content.WriteString("; Hostname             TTL    Class Type  Target\n")

		for _, record := range domain.Records {
			name := record.Hostname
			if name == "" || name == "@" {
				name = domainName + "."
			}

			// Use fixed-width columns for alignment
			content.WriteString(fmt.Sprintf("%-20s %-6d %-4s %-5s %s\n",
				name, record.TTL, "IN", record.Type, record.Target))
		}
	} else {
		content.WriteString("; No records\n")
	}

	return content.String()
}

// generateSerial generates an auto-incrementing serial number
func generateSerial() string {
	now := time.Now()
	return fmt.Sprintf("%04d%02d%02d%02d", now.Year(), now.Month(), now.Day(), now.Hour())
}

// Helper functions
func getStringConfigWithDefault(config map[string]interface{}, key, defaultValue string) string {
	if value, ok := config[key].(string); ok {
		return value
	}
	return defaultValue
}

func getIntConfigWithDefault(config map[string]interface{}, key string, defaultValue int) int {
	if value, ok := config[key].(int); ok {
		return value
	}
	if value, ok := config[key].(float64); ok {
		return int(value)
	}
	if value, ok := config[key].(string); ok {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return defaultValue
}
